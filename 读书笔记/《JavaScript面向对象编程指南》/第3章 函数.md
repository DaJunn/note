# 第3章 函数

掌握函数对于学习任何程序设计语言来说都是非常重要的。尤其对于JavaScript来说，更是如此，因为该语言中的很多功能、灵活性以及表达能力都来自函数。例如，绝大部分语言都有自己专门的面向对象语法，而JavaScript就是通过函数来实现的。在这一章中，我们首先要掌握如下内容：

* 如何定义和使用函数
* 如何向函数传递参数
* 了解我们可以“免费”调用哪些预定义函数
* 了解JavaScript中的变量作用域
* 理解“函数也是数据”的概念，并将其视为一种特殊的数据类型。

理解了上述内容之后，我们就可以继承深入本章的第二部分。在这一部分中，您将会看一些有趣的函数应用：

* 匿名函数的调用
* 回调函数
* 自调函数
* 内嵌函数（在函数内部定义的函数）
* 以函数为返回值的函数
* 能重定义自身的函数
* 闭包

## 3.1 什么是函数

所谓函数，本质上是一种代码的分组形式。我们可以通过这种形式赋予某组代码一个名字，便于日后重用时调用。下面，我们来示范一下函数的声明：

```js
function sum(a, b){
    var c = a + b;
    return c;
}
```

一般来说，函数声明通常由以下几部分组成：

* function子句。
* 函数名称，即这里的sum。
* 函数所需的参数，即这里的a、b。一个函数通常都具有0个或多个参数。参数之间用逗号分割。
* 函数所要执行的代码块，我们称之为函数体。
* return子句。函数通常都会有返回值，如果某个函数没有显式的返回值，我们就会默认它的返回值为undefined。

需要注意的是，一个函数只能有一个返回值，如果我们需要同时返回多个值，可以考虑将其放进一个数组里，以数组元素的形式返回。

### 3.1.1 调用函数

如果我们使用一个函数，就必须要去调用它。调用的方式很简单，只需在函数名后面加一对用以传递参数的括号即可。另外，对于“调用（to call）”这种操作，我们有时也可以将其称之为“请求（to invoke）”某个函数。

现在，让我们来调用一下sum()函数，先将两个参数传递给该函数，然后再将函数的返回值赋值给变量result。具体如下：

```js
var result = sum(1,2);
result;
3
```

### 3.1.2 参数

在定义一个函数的同时，我们往往会设置该函数所需的调用参数。当然，您也可以不给它设定参数，但如果您设定了，而又在调用时忘了传递相关的参数值，JavaScript引擎会自动将其设定为undefined。例如在下面这个调用中，函数返回的是NaN，因为这里试图将1与undefined相加。

```js
sum(1)
NaN
```

而对于那些已经传递进来的参数，JavaScript是来者不拒的。所以基本我们传递的参数过多，多余的那部分也只会被默默地忽略掉。

```js
sum(1,2,3,4,5)
3
```

而且，我们实际上还可以创建一些在参数数量方面更为灵活的函数。这得益于每个函数内部都有一个内建的arguments数组，它能返回函数所接收的所有参数。例如：

```js
function args() {
    return arguments;
}
args();
>>> []
args(1,2,3,4,"true","ninja");
>>> [1,2,3,4,"true","ninja"]
```

通过arguments数组，我们可以进一步完善sum()函数的功能，是之能对任意数量的参数执行求和运算。

```js
function sumOnSteroids(){
    var i,res=0;
    var number_of_params=arguments.length;
    for(i=0;i<number_of_params;i++){
        res+=arguments[i];
    }
    return res;
}
```

下面，我们用不同数量的参数（包括没有参数）来测试该函数，看看它是否能按照我们预计的方式工作：

```js
sumOnSteroids(1,2)
>>> 3
sumOnSteroids(1,1,1)
>>> 3
sumOnSteroids(1,2,3,4)
>>> 10
sumOnSteroids(1,2,3,4,4,3,2,1)
>>> 20
sumOnSteroids(5)
>>> 5
sumOnSteroids()
>>> 0
```

其中，表达式arguments.length返回的是函数被调用时所接收的参数数量。**arguments实际上不是一个数组，而是一个类似数组的对象。**

## 3.2 预定义函数

JavaScript引擎中有一组可供随时调用的内建函数。下面，让我们来了解一下这些函数。在这一过程中，我们会通过一系列具体的函数实践，来帮助您掌握这些函数的参数和返回值，以便最终实现熟练应用，这些内建函数包括：

* parseInt ( )
* parseFloat ( )
* isNaN ( )
* isFinite ( )
* encodeURI ( )
* decodeURI ( )
* encodeURIComponent ( )
* decodeURIComponent ( )
* eval ( )

> **黑盒函数**
>
> 一般来说，当我们调用一个函数时，程序是不需要知道该函数内部的工作细节的。我们可以将其看做一个黑盒子，您只需要给它一些值（作为输入参数），就能获取它输出的返回结果。这种思维适用于任何函数——既包括JavaScript中的内建函数，也包括由任何个人或集体所创建的函数。

### 3.2.1 parseInt ( )

parseInt ( )会试图将其收到的任何输入值（通常是字符串）转换成整数类型输出。如果转换失败就返回NaN。

### 3.2.2 parseFloat ( )

parseFloat ( )的功能与parseInt ( )基本相同，只不过它支持将输入值转换为十进制数。因此，该函数只有一个参数。

与parseInt相同，parseFloat在遇到第一个异常字符时也会放弃，无论剩余的那部分字符串是否可用。

此外，parseFloat ( )还可以接受指数形式的数据（这点与parseInt ( )不同）。

### 3.2.3 isNaN ( )

通过isNaN ( )，我们可以确定某个输入值是否是一个可以参与算术运算的数字。因而，该函数也可以用来检测parseInt ( )和parseFloat ( )的调用成功与否。

该函数也会始终试图将其所接收的输入转换为数字。

isNaN ( )函数是非常有用的，因为NaN自己不存在等值的概念，也就是说表达式NaN===NaN返回的是false，这确实让人觉得有点匪夷所思。

### 3.2.4 isFinite ( )

isFinite ( )可以用来检查输入是否是一个既非infinity也非NaN的数字。

### 3.2.5 URI的编码与反编码

在URL（Uniform Resource Locator，统一资源定位符）或URI（Uniform Resource Identifier，统一资源标识符）中，有一些字符是具有特殊含义的。如果我们想“转义”这些字符，就可以去调用函数encodeURI ( )或encodeURIComponent ( )。前者会返回一个可用的URL，而后者则会认为我们所传递的仅仅是URL的一部分。

encodeURI ( )和encodeURIComponent ( )分别都有各自对应的反转函数：decodeURI ( )和decodeURIComponent ( )。另外，我们有时候还会在一些较旧的代码中看到相似的转义函数和反转义函数，但我们并不赞成使用这些函数来执行相关的操作。

### 3.2.6 eval ( )

eval ( )会将其输入字符串当做JavaScript代码来执行。

尽管，eval ( )在某些情况下还是很有用的，但如果有选择的话，我们应该尽量避免使用它。毕竟在大多数情况下，我们都应该有更优雅的选择，这些选择通常也更易于编写和维护。对于许多经验丰富的JavaScript程序员来说，“Eval is evil”（Eval是魔鬼）是一句至理名言。

因为eval ( )是这样一种函数：

* 性能方面——它是一种由函数执行的“动态”代码，显然要比直接执行脚本慢得多。
* 安全性方面——JavaScript拥有的功能很强大，但这也意味着很大的不确定性，如果您对放在eval ( )函数中的代码没有太多把握，最好还是不要这样使用。

### 3.2.7 一点惊喜——alert ( )函数

接下来，让我们来看一个非常常见的函数——alert ( )。该函数不是JavaScript核心的一部分（即它没有包括在ECMA标准中），而是由宿主环境——浏览器所提供的，是一个用于显示文本的消息对话框。这对于某些调试很有帮助。当然，作为调试工具来说，显示Firebug更适合一些。

当然，在使用这个函数之前，我们必须要明白这样做会阻塞当前的浏览器线程。也就是说，在alert ( )的执行窗口关闭之前，当前所有的代码都会暂停执行。因此，对于一个忙碌的AJAX应用程序来说，alert ( )通常不是一个好的选择。

## 3.3 变量的作用域

这是一个至关重要的问题。特别是当我们从别的语言转向JavaScript时，必须要明白一点，即在JavaScript中，我们不能为变量定义特定的块作用域，但可以定义其所属的函数域。也就是说，如果变量是在某个函数中定义的，那么它在函数以外的地方是不可见的。而如果该变量是定义在if或者for这样的代码块中的，它在代码块之外是可见的。另外，在JavaScript中，术语“全局变量”指的是声明在所有函数之外的变量，而与之相对的是“局部变量”，所指的则是在某个函数中定义的变量。其中，函数内的代码可以像访问自己的局部变量那样访问全局变量，反之则不行。

这里还有一点很重要，即如果我们声明一个变量时没有使用var语句，该变量就会被默认为全局变量。

> **最佳实践**
>
> * 尽量将全局变量的数量降到最低。
> * 总是使用var语句来声明变量

下面，我们再来看一个有趣的示例，它显示了关于本地和全局作用域的另一个重要问题。

```js
var a=123;
function f(){
    alert(a);
    var a=1;
    alert(a);
}
f();
```

您可能会想当然地认为alert ( )第一次显示的123（也就是全局变量a的值），而第二次显示的是1（即局部变量a）。但事实并非如此，第一个alert ( )实际上显示的是“undefined”，这是因为函数始终优于全局域，所以局部变量a会覆盖掉所有与它同名的全局变量，尽管在alert ( )第一次被调用时，a还没有被正是定义（即该值为undefined），但该变量本身已经存在于本地空间了。

## 3.4 函数也是数据

对于JavaScript来说，有一个概念对于我们日后的学习至关重要——即函数是一种数据类型。也就是说，下面两种函数定义在本质上是相同的。

```js
function f(){
    return 1;
}
var f=function(){
    return 1;
}
```

其中，第二种定义方式通常被叫做函数标记法（function literal notation）。

如果我们对函数变量调用typeof，操作符返回的字符串将会是“function”。

```js
function f(){
    reutrn 1;
}
typeof f
>>> "function"
```

所以，JavaScript中的函数是一种数据，只不过这种特殊的数据类型有两个重要的特性：

* 它们所包含的是代码。
* 它们是可执行的（或者说是可调用的）。

和我们之前看到的一样，要调用某个函数，只需要在它的名字后面加一对括号即可。

由于函数也是赋值给变量的一种数据，所以函数的命名规则与一般变量相同——即函数名不能以数字开头，可以由任意的字母、数字和下划线组合而成。

### 3.4.1 匿名函数

在JavaScript中，程序中总是会有一些随处都能看见的数据片段。

函数在本质上与其他变量并无区别，因此它也可以在没有名字的情况下被使用。例如：

```js
function(a){return a;}
```

我们可以将它们设置成函数，这样它们就有了两种优雅的用法：

* 我们可以将匿名函数作为参数传递给其他函数，这样，接收方函数就能利用我们所传递的函数来完成某些事情。
* 我们可以定义某个匿名函数来执行某些一次性任务。

接下来，我们来看两个具体的应用示例，通过其中的细节进一步了解匿名函数。

### 3.4.2 回调函数

既然函数可以像其他数据那样赋值给某个个变量，可以被定义、删除、拷贝，那为什么就不能被当成参数传递给其他函数呢？

回调函数的优势：

* 它可以让我们在不做命名的情况下传递函数（这意味着可以节省全局变量）。
* 我们可以将一个函数调用操作委托给另一个函数（这意味着可以节省一些代码编写工作）。
* 它们页有助于提升性能。

### 3.4.3 回调示例

在编程过程中，我们通常需要将一个函数的返回值传递给另一个函数。在下面的例子中，我们定义了两个函数：第一个是multiplyByTwo ( )，该函数会通过一个循环将其所接受的三个参数分别乘以2，并以数组的形式返回结果；第二个函数addOne ( )只接受一个值，然后将它加1并返回即可。

```js
function multiplyByTwo(a, b, c) {
	var i, ar = [];
	for(i = 0; i < 3; i++) {
		ar[i] = arguments[i] * 2;
	}
	return ar;
}

function addOne(a) {
	return a + 1;
}
```

现在，我们来测试一下这两个函数：

```js
>>> multiplyByTwo(1,2,3);
[2,4,6]
>>> addOne(100)
101
```

接下来，我们要实现这三个元素在两个函数之间的传递，这需要定义一个用于存储元素的数组。我们先从multiplyByTwo ( ) 的调用开始：

```js
>>> var myarr = [];
>>> myarr = multiplyByTwo (10,20,30);
[20,40,60]
```

然后用循环遍历每个元素，并将它们分别传递给addOne ( )。

```js
>>> for (var i = 0; i < 3; i++){ myarr[i] = addOne(myarr[i]);}
>>> myarr
[21,41,61]
```

如您所见，这段代码可以工作，但是显然还有一定的改善空间。特别是这里使用了两个循环，如果数据量很大或循环操作很复杂的话，开销一定不小。因此，我们需要将它们合二为一。这就需要对multiplyByTwo ( )函数做一些改动，使其接受一个回调函数，并在每次迭代操作中调用它。具体如下：

```js
function multiplyByTwo(a, b, c, callback) {
	var i, ar = [];
	for(i = 0; i < 3; i++) {
		ar[i] = callback(arguments[i] * 2);
	}
	return ar;
}
```

函数修改完成之后，之前的工作只需要一次函数调用就够了，我们只需像下面这样将初始值和回调函数传递给它即可：

```js
>>> myarr = multiplyByTwo(1,2,3,addOne);
[3,5,7]
```

我们还可以用匿名函数来代替addOne ( )，这样做可以节省一个额外的全局变量。

```js
>>> myarr = multiplyByTwo(1,2,3,function(a){
    return a+1;
});
[3,5,7]
```

而且，使用匿名函数也更易于随时根据需求调整代码。例如：

```js
>>> myarr = multiplyByTwo(1,2,3,function(a){return a +2});
[4,6,8]
```

### 3.4.4 自调函数

目前我们已经讨论了匿名函数在回调方面的应用。接下来，我们来看匿名函数的另一个应用示例——这种函数可以在定义后自行调用。比如：

```js
(
    function(){
        alerrt('boo');
    }
)()
```

这种语法看上去有点吓人，但其实很简单——我们只需将匿名函数的定义放进一对括号中，然后外面再紧跟一对括号即可。其中，第二对括号起到的是“立即调用”的作用，同时它也是我们向匿名函数传递参数的地方。

```js
(
    function(name){
        alert('Hello '+ name + '!');
    }
)('dude')
```

使用自调匿名函数的好处在于这样不会产生任何全局变量。当然，缺点是这样的函数是无法重复执行的（除非您将它放在某个循环或其他函数中）。这也使得匿名自调函数最适合于执行一些一次性的或初始化的任务。

### 3.4.5 内部（私有）函数

想必我们都记得，函数与其他类型的值本质上是一样的，因此，没有什么理由可以阻止我们在一个函数内部定义另一个函数。

```js
function a(param){
    function b(theinput){
        return theinput * 2;
    };
    return 'The result is ' + b(param);
}
```

我们也可以改用函数标识记法来写这段代码：

```js
var a = function(param){
    var b = function(theinput){
        return theinput * 2;
    };
    return 'The result is ' + b(param);
};
```

当我们调用全局函数a ( )时，本地函数b ( )也会在其内部被调用。由于b ( ) 是本地函数，它在a ( )以外的地方是不可见的，所以我们也能将它称之为私有函数。

```js
>>> a(2);
"The result is 4"
>>> a(8);
"The result is 16"
>>> b(2);
b is not defined
```

使用私有函数的好处主要有以下几点：

* 有助于我们确保全局名字空间的纯净性（这意味着命名冲突的机会很小）。
* 私有性——这使我们可以选择只将一些必要的函数暴露给“外部世界”，并保留属于自己的函数，使它们不为该应用程序的其他部分所用。

### 3.4.6 返回函数的函数

正如之前所提到的，函数始终都会有一个返回值，即便不是显式返回，它也会隐式返回一个undefined。既然函数能返回一个唯一值，那么这个值就也有可能是另一个函数。例如：

```js
function a(){
    alert('A!');
    return function(){
        alert('B!');
    };
}
```

在这个例子中，函数a ( )会在执行它的工作（说“A！”）之后返回另一个函数b ( )。而b ( ) 又会去执行另外一些事情（说“B！”）。我们只需将该返回值赋值给某个变量，然后就可以像使用一般函数那样调用它了。

```js
>>> var newFunc = a();
>>> newFunc();
```

如您所见，上面第一行执行的是alert("A!")，第二行才是alert("B !")。

如果您想让返回的函数立即执行，也可以不用将它赋值给变量，直接在该调用后面再加一对括号即可，效果是一样的。

```js
>>> a()();
```

### 3.4.7 能重写自己的函数

由于一个函数可以返回另一个函数，因此我们可以用新的函数来覆盖旧的。例如在之前的例子中，我们也可以通过a( )的返回值来重写a( )函数自己：

```js
>>> a = a();
```

当前这句依然只会执行alert("A!")，但如果我们再次调用a ( )，它就会执行alert("B!")了。

这对于要执行某些一次性初始化工作的函数来说会非常有用。这样一来，该函数可以在第一次被调用后重写自己，从而避免了每次调用时重复一些不必要的操作。

在上面的例子中，我们是外面来重定义该函数的——即我们将函数返回值赋值给函数本身。但我们也可以让函数从内部重写自己。例如：

```js
function a(){
    alert('A!');
    a = function(){
        alert('B!');
    };
}
```

这样一来，当我们第一次调用该函数时：

* alert("A !")将会被执行（可以视之为一次性的准备操作）。
* 全局变量a将会被重定义，并被赋予新的函数。

而如果该函数再被调用的话，被执行的就将是alert("B!")了。

下面，我们来看一个组合型的应用示例，其中有些技术我们将会在本章最后几节中讨论。

```js
var a = function(){
    function someSetup(){
        var setup ='done';
    }
    function actualWork(){
        alert('Worky-worky');
    }
    someSetup();
    return actualWork;
}();
```

在这个例子中：

* 我们使用了私有函数——someSetup ( )和actualWork ( )。
* 我们也使用了自调函数——函数a ( ) 的定义后面有一对括号，因此它会执行自行调用。
* 当该函数第一次被调用时，它会调用someSetup ( )，并返回函数变量actualWork的引用。请注意，返回值中是不带括号的，因此该结果仅仅是一个函数引用，并不会产生函数调用。
* 由于这里的执行语句是以var a = ...开头的，因而该自调函数所返回的值会重新赋值给a 。

如果我们想测试一下自己对上述内容的理解，可以尝试回答一下这个问题：上面的代码在以下情景中分别会alert ( )什么内容？

* 当它最初被载入
* 之后再次调用a ( )时。