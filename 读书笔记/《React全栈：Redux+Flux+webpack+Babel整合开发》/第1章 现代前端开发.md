# 第1章 现代前端开发

前端开发现在在经历急速发展的阶段。随着应用场景越来越广，需求越来越复杂，社区和官方也在不断地将其规范化和工程化。在本章中，会给读者介绍目前前端开发的发展现状和一些优秀的工具。如果你还在使用比较古老的开发方式，那么不妨跟随步伐，了解一下现阶段的发展。

本章会从3个方面介绍**现代**的前端开发技术，作为了解React和webpack的背景知识。

* ES6——新一代的JavaScript语言标准。
* Component组件和模块的发展历程。
* 前端开发的常用工具：
  * 包管理器（Package Manager），用来下载和管理前端代码库。
  * 任务流工具（Task Runner），用来执行一系列开发中的任务。
  * 模块打包工具（Bundler），用来转换和合并前端代码的模式。

## 1.1 ES6——新一代的JavaScript标准

JavaScript这门脚本语言一直被人诟病（所以薄薄的一本《JavaScript语言精粹》让很多读者捧为圣经），再加上浏览器兼容性的问题，令很多前端开发者搞到特别苦恼。如今前端开发发展又如此迅速，这促使了ECMA组委会在修订JavaScript语言新版本时，不仅在质量上不断加以完善，同时加快了更新的速度。

ES6（或者被称为ES2015）被称为JavaScript历史上最重大的一次变革，该标准最终敲定与2015年6月，提供了非常多语言级别的新的特性。这是一个可以载入前端发展史册的重大事件。本书全面使用了ES6标准，在这里会简单描述一些在本书中使用的ES6的特性，给读者一个关于最新标准的直观概念。如果想了解更多变化和特性，建议阅读阮一峰老师编写的《ECMAScript 6 入门》 。

### 1.1.1 语言特性

**1. const、let关键字**

众所周知，在JavaScript中，变量默认是全局性的，只存在函数级作用域，声明函数曾经是创造作用域的唯一方法。这点和其他编程语言存在差异，其他语言大多数都存在块级作用域。所以在ES6中，新提出的let关键字使这个缺陷得到了修复。

```javascript
if(true){
    let a='name';
}
console.log(name);
// ReferenceError: a is not defined
```

同时还引入的概念是const，用来定义一个常量，一旦定义以后不可以修改，不过如果是引用类型的，那么可以改变它的属性。

```javascript
const MYNAME='viking';
MYNANME='kitty';
// "CONSTANT" is read-only
const MYNAME={foo:'viking'};
MYNAME.foo='kitty';
// 可以正常运行
```

**2. 函数**

* **箭头函数**

箭头函数是一种更简单的函数声明方式，可以把它看作是一种语法糖，箭头函数永远是匿名的。

```javascript
let add=(a,b)=>{return a+b;}
// 当后面是表达式(expression)的时候，还可以简写成
let add=(a,b)=>a+b;
// 等同于
let add=function(a,b){
    return a+b;
}
// 在回调函数中应用
let numbers=[1,2,3];
let doubleNumbers=numbers.map((number)=>number*2);
console.log(doubleNumbers);
// [2,4,6]看起来很简便吧
```

* this在箭头函数中的使用

在工作中经常会遇到这样的问题，就是this在一个对象方法中嵌套函数。

```javascript
let age=2;
let kitty={
    age:1,
    grow:function(){
        setTimeout(function(){
            console.log(++this.age);
        },100);
    }
};

kitty.grow();
// 3
```

在对象方法的嵌套函数中，this会指向global对象，这被看作是JavaScript在设计上的一个重大缺陷，一般都会用一些hack来解决它，如下。

```javascript
let kitty={
    age:1,
    grow:function(){
        const self=this;
        setTimeout(function(){
            console.log(++self.age);
        },100);
    }
};
// 或者
let kitty = {
    age:1,
    grow:function(){
        setTimeout(function(){
            console.log(this.age);
        }.bind(this),100);
    }
}
```

现在有了箭头函数，可以很轻松地解决这个问题。

```javascript
let kitty = {
	age:1,
    grow:function(){
        setTimeout(()=>{
            console.log(this.age);
        },100);
    }
}
```

* **函数默认参数**

ES6没有出现之前，面对默认参数都会让人感到很痛苦，不得不采用各种hack，比如说：values=values||[]。现在一切都变得轻松很多。

```javascript
function desc(name='Petter',age=5){
    return name+' is '+age+' years old';
}
desc();
//Petter is 5 years old
```

* **Rest参数**

当一个函数的最后一个参数有“…”这样的前缀，它就会变成一个参数的数组。

```javascript
function test(...args){
    console.log(args);
}
test(1,2,3);
// [1,2,3]
function test2(name, ...args){
    console.log(args);
}
test2('Peter',2,3);
//[2,3]
```

它和arguments有如下区别：Rest参数只是没有指定变量名称的参数数组，而arguments是所有参数的集合；arguments对象不是一个真正的数组，而Rest参数是一个真正的数组，可以使用各种方法，比如sort、map等。有了这两个理由，是时候告别arguments，拥抱可爱的Rest参数了。

**3. 展开操作符**

刚才在函数中见到了使用“…“操作符来实现函数参数的数组，其实这个操作符的魔力不仅仅如此。它被称为展开操作符，允许一个表达式在某处展开，在存在多个参数（用于函数调用）、多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方就会出现这种情况。

* **用于函数调用**

如果在之前的JavaScript中，想让函数把一个数组依次作为参数进行调用，一般会如下这样做。

```js
function test(x,y,z){};
var args=[1,2,3];
test.apply(null,args);
```

有了ES6的展开运算符，可以简化这个过程。

```js
function test(x,y,z){};
let args=[0,1,2];
test(...args);
```

* **用于数组字面量**

在之前的版本中，如果想创建含有某些元素的新数组，常常会用到splice、concat、push等方法，如下。

```js
var arr1 = [1, 2, 3];
var arr2 = [4, 5, 6];
var arr3 = arr1.concat(arr2);
console.log(arr3);
//1,2,3,4,5,6
```

使用展开运算符以后就简便了很多，如下。

```js
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = [...arr1, ...arr2];
console.log(arr3);
// [ 1, 2, 3, 4, 5, 6 ]
```

* **对象展开运算符**

数组的展开运算符简单易用，那么对象有没有这个特性？

```js
let mike = {
    name: 'mike',
    age: 50
};
mike = {
    ...mike,
    sex: 'male'
};
console.log(mike);
// {
//     name: 'mike',
//     age: 50,
//     sex: 'male'
// }
```

对象的展开其实已经被提上日程，只不过它是ES7的提案之一，它可以让你以更简洁的形式将一个对象可枚举的属性复制到另外一个对象上。这一特性可以借助后面介绍的Babel和它的插件来实现。其实React已经走在了时代的前沿，在JSX语法中已经开始采用这种写法，我们会在后面的章节学习到这个特性。

**4. 模板字符串**

在ES6之前的时代，字符串的拼接总是一件令人不爽的事情，但是在ES6来临的时代，这个痛处也要被治愈了。

```js
// 之前总会做这些事情
var viking = 'viking';
var b = 'My name is ' + viking + '!';
// 多行字符串
var longStory_ = 'This is a long story,' +
    'this is a long story,' +
    'this is a long story';
// 有了ES6现在可以这样做
// 注意这里不是引号而是`这个符号
let name = 'viking';
let a = 'My name is ${name} !';
let longStory = `This is a long story,
this is a long story
this is a long story`;

console.log(longStory);
```

**5. 解构赋值**

解构语法可以快速从数组或者对象中提取变量，可以用一个表达式读取整个结构。

* **解构数组**

```js
let foo = ['one', 'two', 'three'];
let [one, two, three] = foo;

console.log(`${one},${two},${three}`);
// ['one', 'two', 'three']
```

* **解构对象**

```js
let person = {
    name: 'viking',
    age: 20
};
let {
    name,
    age
} = person;

console.log(`${name},${age}`);
```

解构赋值可以看作一种语法糖，它受Python语言的启发，可以提高效率。

**6. 类**

众所周知，在JavaScript的世界里是没有传统类的概念的，它使用原型链的方式来完成继承，但是声明的方式看起来总是怪怪的，所以ES6提供了class这个语法糖，让开发者可以模仿其他语言类的声明方式，看起来更加明确清晰。需要注意的是.class并没有带来新的结构，而只是原来原型链方式的一种语法糖。

```js
class Animal {
    // 构造函数
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    shout() {
        return `My name is ${this.name}, age is ${this.age}`;
    }
    // 静态方法
    static foo() {
        return 'Here is a static method';
    }
}

const cow = new Animal('betty', 2);
cow.shout();
// My name is betty, age is 2
Animal.foo();
// Here is a static method

class Dog extends Animal {
    constructor(name, age = 2, color = 'black') {
        // 在构造函数中可以直接调用super方法
        super(name, age);
        this.color = color;
    }
    shout() {
        // 在非构造函数中不能直接使用super方法
        // 但是可以采用super().+方法名字调用父类方法
        return super.shout() + `, color is ${this.color}`;
    }
}

const jackTheDog = new Dog('jack');
let sayHello = jackTheDog.shout();
console.log(sayHello);
// "My name is jack, age is 2, color is black"
```

**7. 模块**

JavaScript模块化代码是一个古老的话题，从前端开发这个职业诞生到现在，一直都在不断地进化，它的发展也从另外一个侧面反映了前端项目越来越复杂、越来越工程化。

在ES6之前，JavaScript并没有对模块做出任何定义，于是先驱者们创造了各种各样的规范来完成这个任务。伴随着Require.js的流行，它所推崇的AMD格式也成了开发者的首选。在这之后，Node.js诞生了，随之而来的是CommonJS格式，再之后browserify的诞生，让浏览器端的开发也能使用这种格式。直到ES6的出现，模块这个观念才真正有了语言特性的支持，现在来看看它是如何被定义的。

```js
// hello.js 文件
// 定义一个命名为hello的函数
function hello(){
    console.log('Hello ES6');
}
// 使用export导出这个模块
export hello;

// main.js
// 使用import加载这个模块
import { hello } from './hello'；
hello();
// Hello ES6
```

上面的代码就完成了模块的一个最简单的例子，使用import和export关键字完成模块的导入和导出。当然也可以完成一个模块的多个导出，请看下面的例子。

```js
// hello.js
export const PI=3.14;
export function hello(){
    console.log('Hello ES6');
}
export let person={name:'viking'};

// mian.js
// 使用对象解构赋值加载这3个变量
import {PI,hello,person} from './hello';

// 也可以将这个模块全部导出
import × as util from './hello'；
console.log(util.PI);
// 3.14
```

还可以使用default关键字来实现模块的默认导出。

```js
// hello.js
export default function(){
    console.log('Hello ES6');
}

// main.js
import hello from './hello';
hello();
// Hello ES6
```

模块的官方定义对于JavaScript来说是具有划时代意义的，它让各种关于JavaScript模块化标准的争斗落下帷幕，开发者不用再为选择什么样的模块标准而苦恼，每个人都可以开心地使用ES6的模块标准。

### 1.1.2 使用Babel

**1. 认识Babel**

正如上面所介绍的，作为一种语言，JavaScript在不断发展，各种新标准和提案层出不穷，但是由于浏览器的多样性导致有可能几年之内都无法广泛普及，而Babel可以让你提前使用这些语言特性，它是一种多用途的JavaScript编译器，它把最新版本的JavaScript编译成当下可以执行的版本。简而言之，利用Babel就可以让我们在当前的项目中随意地使用这些最新的ES6语法特性。

安装Babel CLI，这是一个可以在命令行中使用Babel编译的方法。

```bash
npm install babel-cli -g
```

现在来写一段ES6代码

```js
// es6.js
let numbers = [1, 2, 3];
let doubleNumbers = numbers.map((number) => number * 2);
console.log(doubleNumbers);
```

然后使用Babel来编译这段代码。

```bash
 babel es6.js -o compiled.js
```

打开compiled.js，发现只是把es6.js的代码复制了过来，没有任何的处理。因为还没有配置Babel怎样去编译代码。

**2. 配置**

Babel是通过安装插件（plugin）或者预设（preset，就是一组设定好的插件）来编译代码的。

先创建一个配置文件.babelrc。

```js
// .babelrc
{
    "presets": [],
    "plugins": []
}
```

下面来安装一个预设，它可以把ES6代码编译成ES5代码。

```bash
npm install --save-dev babel-preset-es2015
```

安装完后，在node_modules/babel-preset-es2015/node_modules文件夹中（npm v3+的话则是在node_modules文件夹中），会发现有一系列的插件。每个插件都有各种独特的功能，用来共同完成ES6代码的编译。如图1-1所示为Babel preset的例子。

```bash
babel-code-frame
babel-helper-call-delegate
babel-helper-define-map
babel-helper-function-name
babel-helper-get-function-arity
babel-helper-hoist-variables
babel-helper-optimise-call-expression
babel-helper-regex
babel-helper-replace-supers
babel-messages
babel-plugin-check-es2015-constants
babel-plugin-transform-es2015-arrow-functions
babel-plugin-transform-es2015-block-scoped-functions
babel-plugin-transform-es2015-block-scoping
babel-plugin-transform-es2015-classes
babel-plugin-transform-es2015-computed-properties
babel-plugin-transform-es2015-destructuring
babel-plugin-transform-es2015-duplicate-keys
babel-plugin-transform-es2015-for-of
babel-plugin-transform-es2015-function-name
babel-plugin-transform-es2015-literals
babel-plugin-transform-es2015-modules-amd
babel-plugin-transform-es2015-modules-commonjs
babel-plugin-transform-es2015-modules-systemjs
babel-plugin-transform-es2015-modules-umd
babel-plugin-transform-es2015-object-super
babel-plugin-transform-es2015-parameters
babel-plugin-transform-es2015-shorthand-properties
babel-plugin-transform-es2015-spread
babel-plugin-transform-es2015-sticky-regex
babel-plugin-transform-es2015-template-literals
babel-plugin-transform-es2015-typeof-symbol
babel-plugin-transform-es2015-unicode-regex
babel-plugin-transform-regenerator
babel-plugin-transform-strict-mode
babel-preset-es2015
babel-runtime
babel-template
babel-traverse
babel-types
```

将这个preset添加到配置文件中。

```json
// .babelrc
{
    "presets": ["es2015"],
    "plugins": []
}
```

现在配置完毕，再次运行命令以后，打开compiled.js文件，发现编译已经完成了。

```js
"use strict";

// es6.js
var numbers = [1, 2, 3];
var doubleNumbers = numbers.map(function (number) {
  return number * 2;
});
console.log(doubleNumbers);
```

在1.1.1节语言特性里面介绍过ES7中的对象展开操作符，那么这里用一个单独的插件那实现这个功能，演示一下Babel单独插件的配置使用。

安装object-rest-spread插件。

```bash
npm install babel-plugin-transform-object-rest-spread --save-dev
```

添加至配置文件。

```json
// .babelrc
{
    "presets": ["es2015"],
    "plugins": ["transform-object-rest-spread"]
}
```

写一段使用对象展开符的代码。

```js
let mike = {
    name: 'mike',
    age: 40
};
mike = {
    ...mike,
    sex: 'male'
};
console.log(mike);
```

打开编译以后的代码文件，发现如下。

```js
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var mike = {
    name: 'mike',
    age: 40
};
mike = _extends({}, mike, {
    sex: 'male'
});
console.log(mike);
```

这个插件其实就是添加了另外一个`_extends`方法来完成这个功能。

经过这两个例子以后，不难得出这样的结论：Babel的核心概念就是利用一系列的plugin来管理编译规则，通过不同的plugin，它不仅可以编译ES6代码，还可以编译React JSX语法或者是CoffeeScript等，甚至可以使用还在提案阶段的ES7的一些特性，这就足以看出它的可扩展性和易用性等魔力。在以后的章节中，会介绍它和webpack、React如何共同构建一个完美的开发环境。

### 1.1.3 小结

在本书中将要使用的ES6特性大体就有这些，这么多全新的特性是不是让你跃跃欲试？但是兼容性一直是前端领域不得不谈的问题，很多版本的浏览器都无法支持所有ES6的特性，但是随着一个出色的编译器Babel的诞生，在现在的项目中，借助它的帮助，就可以完全释放ES6的魔力。

有了ES6和Babel，JavaScript开发可谓如虎添翼，可以写出更简洁、健壮的代码。

## 1.2 前端组件化方案

首先要区分两个概念：模块（module）与组件（component）。模块是语言层面的，在前端领域我们说的module一般都是指JavaScript module，往往表现为一个单独的JS文件，对外暴露一些属性或方法。前端组件则更多是业务层面的概念，可以看成一个可独立使用的功能实现，往往表现为一个UI部件（并不绝对），比如一个下拉菜单、一个富文本编辑器或者一个路由系统。一个组件包含它所需要的所有资源，包括逻辑（JavaScript）、样式（CSS）、模板（HTML/template），甚至图片与字体。

因而，一个组件有时仅仅是一个JavaScript模块，而更多时候不仅是一个JavaScript模块。前端的组件化方案都不可避免要以JavaScript的模块化方案为基础。

### 1.2.1 JavaScript模块化方案

在ES6之前，JavaScript并没有原生的模块，JavaScript开发者通过各种约定或妥协实现了模块的特征，如独立的命名空间、暴露属性与方法的能力等。粗略分析的话，这一过程大致经历了3个阶段：全局变量+命名空间（namespace）、AMD&CommonJS、ES6模块。