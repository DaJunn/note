# 第9章 指针

**指针（pointer）**是对数据对象或函数的一种引用。指针有多种用途，例如定义“传址调用”函数，它还可以实现动态数据结构，例如链表和树。

通常，管理大量数据的有效方法不是直接处理数据本身，而是使用指向数据的指针。例如，如果需要对大量的大型记录进行排序，对指向该记录的指针列表进行排序效率要比直接对记录排序高得多，因为这样无需在内存中移动数据。类似地，如果需要把大型记录传入函数，传递指向该记录的指针会比直接传递记录本身更经济，即使函数不需要修改该记录。

## 9.1 声明指针

指针代表了一个对象或函数的地址和类型。如果一个对象或函数具有T类型，那么指向它的指针就具有一个衍生出的指向T的**指针类型（pointer to T）**。例如，如果var是一个float变量，那么表达式&var（其值是该float变量的地址）属于指向float的指针类型，按照C语言表达，就是float *类型。指向任何T类型的指针也被简称为**T指针（T point）**。因此，&var中地址运算符会生成一个float指针。

因为var没有在内存中移动位置，所以表达式&var是一个常量指针。然而，C也允许使用指针类型来定义变量。指针变量存储的是另一个对象或函数的地址。我们后面会进一步讨论指向数组和函数的指针。首先，看看如何声明指向非数组对象的指针，语法如下：

```
类型 * [类型限定符列表] 名称 [= 初始化器];
```

在声明中，星号（*）表示“指向……的指针”。标识符“名称”被声明为一个对象，其对象类型为“类型”，也就是“指向‘类型’的指针”。类型限定符为可选择项，可能包含const、volatile和restrict的任意组合。关于指针类型的限定符，请参见9.3节。

下面是一个简单的例子：

```c
int *iPtr;//声明iPtr作为一个指向int的指针
```

int类型是iPtr指针所指向的对象的类型。为了让指针能够引用到给定的对象，将该对象的地址赋值给该指针。例如，如果iVar是一个int变量，那么下面的赋值操作会让iPtr指向变量iVar：

```c
iPtr = &iVar;//使得iPtr指向变量iVar
```

一般形式的声明包含了用逗号分隔开的声明符列表，每个声明符声明了各自的标识符（见第11章）。在指针声明中，星号（*）是声明符的一部分。我们可以在一个声明中同时定义和初始化变量iVar和iPtr，如下所示：

```c
int iVar = 77,*iPtr = &iVar;//定义一个int变量，以及一个指向它的指针
```

这两个声明中的第二个声明，将iPtr初始化为变量iVar的地址，这使得iPtr指向iVar。图9-1展示了变量iVar和iPtr在内存中可能的排列方式。这里的地址为示例所需，纯粹是虚构的。如图9-1所示，存储在指针iPtr中的值是对象iVar的地址。

![1563259514871](assets/1563259514871.png)

在验证与调试时，输出地址常常有助于判断。函数printf()提供了一种格式化修饰符：%p。下面语句输出变量iPtr的地址和内容：

```c
printf("Value of iPtr (i.e. the address of iVar):  %p\n"
       "Address of iPtr:                           %p\n",iPtr,&iPtr);
```

无论指针所指对象的类型是什么，在内存中指针空间的大小（例如，表达式sizeof(iPtr)）都是一样的。换句话说，char指针所占用的空间和指向大型结构的指针所占用的空间一样。在32位计算机上，指针通常是4个字节长。

### 9.1.1 空指针

当把一个空指针常量转换为指针类型时，所得到的结果就是空指针（null pointer）。空指针常量（null pointer constant）是一个值为0的整数常量表达式，或者是一个void *类型的表达式（请参见4.2.3.3节）。在头文件stdlib.h、stdio.h以及其他头文件中，宏NULL被定义为空指针常量。

空指针有别于其他指向对象或函数的有效指针。因此，当返回值为指针的函数出现执行失败的情况时，它通常会使用空指针作为返回值。标准函数fopen()正是这样的一个例子，如果在指定的模式下打开某文件失败时，该函数会返回一个空指针。

```c
#include <stdio.h>

int main() {
    FILE *fp = fopen("demo.txt", "r");
    if (fp == NULL) {// 也可以被写成：if(!fp)
        // 错误：无法打开demo.txt文件进行读取
        perror("ERROR");
    }
    return 0;
}
```

如果有必要的话，空指针会被隐式地转换成其他指针类型，以进行赋值运算或者是进行==或!=的比较运算。因此，上述例子不需要使用转型运算符（请参见4.2.3节）。

### 9.1.2 void指针

指向void的指针，或者简称为void指针（void pointer），是类型为void *的指针。因为没有对象类型是void，所以void *被称为万能指针类型。换句话说，void指针可以代表任何为对象的地址，但不代表该对象的类型。若想获取内存中的对象，必须先把void指针转换为合适的对象指针。

若想声明一个可以接收任何类型指针参数的函数，可以将所需的参数设定为指向void的指针。当调用这样的函数时，编译器会隐式地将对象指针参数转换为void指针。常见的例子如标准函数memset()，它被声明在头文件string.h中，其原型如下：

```c
void *memset( void *s, int c, size_t n);
```

函数memset()将c的值赋值到从地址s开始的n个内存字节中。例如，下面的函数调用会将0值赋值到结构变量record中的每个字节：

```c
struct Data {/*……*/}record;
memset(&record, o, sizeof(record));
```

