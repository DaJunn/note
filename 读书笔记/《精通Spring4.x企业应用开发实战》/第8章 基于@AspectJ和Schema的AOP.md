# 第8章 基于@AspectJ和Schema的AOP

在上一章的学习中我们发现，在Spring中定义一个切面是比较烦琐的，需要实现专门的接口，并进行一些较为复杂的配置，Spring AOP配置是被批评最多的地方。Spring听到了这方面的声音，下决心解决这一问题，并取得了很好的突破。如今，Spring AOP已经焕然一新，用户可以使用@AspectJ注解非常容器地定义一个切面，而不需要实现任何接口。对于没有使用Java 5.0的项目，可以通过基于Schema的配置定义切面，其方便程度和基于@AspectJ注解的配置相差无几。此外，Spring还可以使用AspectJ语言编写切面，发扬二者的长处：用AspectJ织入切面，并让Spring容器管理这些切面。

**本章主要内容：**

* Java 5.0注解知识
* 通过@AspectJ定义切面
* 切点函数讲解
* 绑定连接点参数
* 基于Schema配置定义切面
* Spring LTW

**本章亮点：**

* 对切点表达式函数进行深入分析
* 深入讲解集成AspectJ的过程

## 8.1 Spring对AOP的支持

Spring在新版本中对AOP功能进行了重要的增强，主要表现在以下几个方面：

* 新增了基于Schema的配置支持，为AOP专门提供了aop命名空间。
* 新增了对AspectJ切点表达式语言的支持。@AspectJ是AspectJ 1.5新增的功能，它通过Java 5.0的注解技术，允许开发者在POJO中定义切面。Spring使用和@AspectJ相同的风格的注解，并通过AspectJ提供的注解库和解析库处理切点。当然，由于Spring只支持方法级的切点，所以仅对@AspectJ提供了有限的支持。
* 可以无缝地集成AspectJ。AspectJ提供了语言级切面的实现，Spring无意开发一个重复的东西，Spring对开源世界里一切优秀的东西向来采取兼收并蓄的态度。

这里所说的Spring AOP包括基于XML配置的AOP和基于@AspectJ注解的AOP，这两种方法虽然在配置切面时的表现方式不同，但底层都采用了动态代理技术（JDK或CGLib动态代理）。Spring可以集成AspectJ，但AspectJ本身并不属于Spring AOP的范畴。

一般情况下，对于开发JAVA EE企业应用的开发者而言，Spring AOP已经可以满足使用的要求。虽然AspectJ提供对AOP更为细致的实现，但像实例化切面、属性访问切面、条件切面等功能，在实际应用中并不常用。

如果是基于Java 5.0 的项目，推荐使用Spring提供的@AspectJ配置方式，因为它以更简单、更直接的方式应用切面。

## 8.2 Java 5.0注解知识快速进阶

### 8.2.1 了解注解

注解是代码的附属信息，它遵循一个基本原则：注解不能直接干扰程序代码的运行，无论增加或删除注解，代码都能够正常运行。

### 8.2.2 一个简单的注解类

## 8.10 小结

在本章中，首先介绍了Java 5.0 的注解知识，它是学习@AspectJ的基础。使用@AspectJ定义切面比基于接口定义切面更加直观、更加简洁，成为Spring所推荐的切面定义方式。

掌握切点表达式语法和切点函数是学习@AspectJ的重点，我们分别对9个切点函数进行了详细的讲述。切点表达式非常灵活，拥有强大的切点表达能力，读者可以使用通配符、切点函数及切点运算符定义切点。

如果项目因某种原因无法使用Java 5.0，则可以采用基于Schema配置的方式继续使用AspectJ的切点表达式和增强定义，基于Schema的配置采用`<aop:aspect>`描述@Aspect类所描述的相同信息，只是换了一种方法而已。此外，还可以通过`<aop:advisor>`复用旧系统已有的Advice，并配合使用AspectJ的切点表达式。

在切点表达式中，大多数切点函数都可以绑定连接点方法的入参，以便增强方法访问连接点信息。此外，用户也可以简单地将增强方法的第一个入参定义为JoinPoint访问连接点的上下文。

Spring AOP虽然提供了4种切面定义方式，但其底层实现却是相同的，也就是说，表象不同，本质归一。所以如果需要，则可以放心地混合使用这些不同的定义方式。

Spring还支持LTW的功能，允许通过AspectJ定义切面，在类加载期通过类文件转换织入切面。

